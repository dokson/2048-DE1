#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 3cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 0 0 0 4
\bullet 1 0 8 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
2048 - VHDL su Altera DE1
\end_layout

\begin_layout Author
Alessandro Colace (0000700279) e Giacomo Gezzi (0000688447)
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduzione
\end_layout

\begin_layout Section
Storia
\end_layout

\begin_layout Standard

\series bold
2048
\series default
 è un videogioco a giocatore singolo pubblicato on-line il 9 marzo 2014
 da Gabriele Cirulli, uno sviluppatore web italiano di 19 anni, il cui obiettivo
 è quello di far scorrere le piastrelle su una griglia, unirle e creare
 una tessera con il numero 
\series bold
2048
\series default
.
 
\end_layout

\begin_layout Standard
Considerato come un rompicapo, è molto simile a 
\series bold
\emph on
Threes!
\series default
\emph default
, applicazione pubblicata un mese prima, ma versioni simili includono anche
 elementi provenienti da 
\emph on
Doge, Doctor Who, Flappy Bird e Tetris
\emph default
.
 
\end_layout

\begin_layout Standard
L'autore definisce questi cloni come 
\emph on

\begin_inset Quotes fld
\end_inset

La bellezza dei software open source
\emph default

\begin_inset Quotes frd
\end_inset

 e non si oppone a loro in quanto, dice, 
\emph on

\begin_inset Quotes fld
\end_inset

aggiungono nuove modifiche creative per il gioco
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Section
Meccanica del gioco
\end_layout

\begin_layout Standard
A 
\series bold
2048
\series default
 si gioca su una semplice griglia grigia di formato
\series bold
 4×4
\series default
 in cui scorrono caselle di 
\series bold
colori diversi
\series default
, con 
\series bold
numeri diversi
\series default
 (
\emph on
tutti i numeri sono potenze di 2
\emph default
), senza intralci quando un giocatore le muove.
 Il gioco usa i
\series bold
 tasti freccia della tastiera 
\series default
per spostare tutte le caselle 
\bar under
a sinistra o a destra oppure in alto o in basso
\bar default
.
 
\emph on
Se due caselle contenenti lo stesso numero si 
\series bold
scontrano
\series default
\emph default
 mentre si 
\series bold
\emph on
muovono
\series default
\emph default
, si 
\series bold
fondono in un'unica casella
\series default
 che avrà come numero la
\series bold
 somma delle due tessere che si sono scontrate
\series default
 e dunque il 
\series bold
colore corrispondente
\series default
.
 Ad ogni turno, un nuova tessera con il valore di 2 apparirà in modo casuale
 in un punto vuoto sul tabellone.
\end_layout

\begin_layout Standard
Inoltre, un tabellone in alto a destra tiene traccia del punteggio dell'utente.
 Il punteggio dell'utente inizia da zero e viene incrementato ogni volta
 che due tessere si combinano, con il valore della nuova casella.
\end_layout

\begin_layout Standard

\series bold
La partita è vinta
\series default
 quando, a furia di far combinare le tessere,
\series bold
 si riesce a crearne una con il numero 2048
\series default
: da qui il nome del gioco.
\end_layout

\begin_layout Standard
Se il giocatore 
\series bold
non può muovere le caselle
\series default
 (
\emph on
non ci sono spazi vuoti e senza tessere adiacenti con lo stesso valore
\emph default
), 
\series bold
finisce la partita
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/2048_Screenshot.png
	scale 48

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio della Schermata di Gioco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Colori delle caselle
\end_layout

\begin_layout Standard
Nel gioco, ogni numero è abbinato ad un colore differente.
 Tutti sono "colori caldi", ovvero colori derivati dal rosso, eccetto per
 il 2 che presenta una tonalità di grigio.
\end_layout

\begin_layout Standard
Il 4 presenta una tonalità beige mentre dall'8 al 64 i numeri sono abbinati
 a varie tonalità di rosso che variano dal mattone per l'8 al sangue per
 il 64.
\end_layout

\begin_layout Standard
Raggiunto il 128, i numeri tornano chiari, utilizzando la tonalità ocra
 fino al 2048: da un pallido giallo del 128, infatti le tonalità s'intensificano
 con il 256, il 512 e il 1024 sino a giungere il 2048 che è di colore ocra
 intenso/oro.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/colours.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Colori originali delle caselle del gioco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Analisi
\end_layout

\begin_layout Section
Realizzazione di un prototipo
\end_layout

\begin_layout Standard
Il gioco originale è stato scritto in 
\series bold
JavaScript
\series default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://gabrielecirulli.github.io/2048/
\end_layout

\end_inset

, ma, avendo la necessità di iniziare un progetto utilizzando il codice
 
\series bold
VHDL
\series default
 
\emph on
da zero
\emph default
, abbiamo preferito riscriverci dapprima un piccolo prototipo in 
\series bold
JAVA
\series default
 in modo da riuscire a capire meglio il codice del gioco..
\end_layout

\begin_layout Standard
Abbiamo scelto 
\emph on
JAVA
\emph default
 per la familiarità con questo linguaggio di programmazione: in questo modo
 è stato più semplice fare svariati test in una fase preliminare e riuscire
 ad avere un quadro generale dello sviluppo, in vista del futuro utilizzo
 di 
\series bold
Quartus II 
\series default
di 
\emph on
Altera
\emph default
.
\end_layout

\begin_layout Section
VHDL
\end_layout

\begin_layout Standard
Il linguaggio scelto per descrivere l’architettura implementata è il 
\series bold
VHDL-93
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
http://it.wikipedia.org/wiki/VHDL
\end_layout

\end_inset

, per l’ampio utilizzo che se ne fa praticamente in tutta Europa per la
 progettazione hardware che lo porta ad essere uno standard di fatto in
 materia.
 
\end_layout

\begin_layout Standard
Il 
\series bold
VHDL
\series default
 è un linguaggio per la descrizione dell’hardware (
\emph on
Hardware Description Language
\emph default
), che può essere utilizzato per la documentazione, la simulazione e la
 sintesi di sistemi digitali.
 Inizialmente, nei primi anni ’80, lo sviluppo del VHDL è stato supportato
 dal dipartimento della difesa statunitense, nell’ambito di un progetto
 denominato 
\series bold
VHSIC
\series default
 (
\emph on
Very High Speed Integrated Circuits
\emph default
).
 
\end_layout

\begin_layout Standard
Il linguaggio è nato quindi con lo scopo di 
\series bold
fornire una descrizione non ambigua di un sistema digitale
\series default
, che potesse essere interpretata univocamente dai vari progettisti impegnati
 nello sviluppo del sistema stesso.
 Una delle caratteristiche richieste al VHDL è la possibilità di 
\emph on
simulare il sistema descritto
\emph default
, sia a livello funzionale sia 
\bar under
tenendo in considerazione tutte le non idealità che si hanno in un circuito
 reale
\bar default
.
 
\end_layout

\begin_layout Section
Altera DE1
\end_layout

\begin_layout Standard
Avendo a disposizione una scheda 
\series bold
Terasic DE1 
\series default
che monta 
\series bold
FPGA Cyclone II di ALTERA
\series default
, la quale mette a disposizione numerose features per sviluppare variegati
 progetti.
 Sono presenti su di essa una serie di pulsanti ed interruttori, un display
 7 segmenti a 4 cifre, una porta VGA, una porta PS/2 e molte altre interfacce
 I/O.
 
\end_layout

\begin_layout Standard
Per realizzare la nostra versione 
\series bold
VHDL 
\series default
del gioco 
\series bold
2048
\series default
,
\series bold
 
\series default
abbiamo deciso di utilizzare i seguenti componenti della scheda fornitaci
 dal professore:
\end_layout

\begin_layout Itemize
l'interfaccia 
\series bold
PS/2
\series default
 tramite tastiera, per dare i comandi di input
\end_layout

\begin_layout Itemize
l'interfaccia 
\series bold
VGA
\series default
 per visualizzare su monitor lo stato della partita
\end_layout

\begin_layout Itemize
il 
\series bold
display da 7 segmenti a 4 cifre
\series default
 per visualizzare il punteggio corrente della partita
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/altera_de1.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Altera Terasic DE1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Quartus II
\end_layout

\begin_layout Standard
Per poter programmare il progetto sulla scheda, è necessario utilizzare
 
\series bold
Quartus II
\series default
, un software di 
\series bold
Altera 
\series default
che, oltre a permettere di interfacciare computer e DE1, è un comodo ambiente
 di sviluppo con cui generare il progetto stesso.
 
\end_layout

\begin_layout Standard
La versione che abbiamo scelto di utilizzare per realizzare questo progetto
 è la 
\series bold
9.1 Web Edition
\series default
, con licenza gratuita.
 Quartus permette sia di comporre una logica unendo porte logiche in uno
 schematico, sia di sintetizzarne di più complesse, tramite descrizione
 
\emph on
Verilog o VHDL
\emph default
, o ad un livello di astrazione più alto, ad esempio con una macchina a
 stati finiti.
\end_layout

\begin_layout Chapter
Implementazione
\end_layout

\begin_layout Section
Modelli di Realizzazione
\end_layout

\begin_layout Subsection
Datapath - Control Unit
\end_layout

\begin_layout Standard
La realizzazione del progetto è stata suddivisa in diversi moduli VHDL in
 accordo col 
\series bold
modello Datapath - Control Unit
\series default
, racchiudendo nel 
\series bold
\emph on
Datapath
\series default
\emph default
 la 
\series bold
\emph on
logica di gioco
\series default
\emph default
 (meccanismo dei movimenti in seguito alle mosse, stato attuale della griglia
 di gioco, punteggio, ...) e nella 
\series bold
\emph on
Control Unit
\series default
\emph default
 la gestione degli input del gioco, ovvero i comandi relativi alle 4 mosse
 effettuabili dal giocatore (
\noun on
SU, GIU, DESTRA, SINISTRA
\noun default
) o il riavvio della partita, ma anche la notifica dello stato della partita
 (
\noun on
GameOver, Vittoria
\noun default
) al giocatore.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Datapath-ControlUnit.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
DataPath & Control-Unit
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model - View - Controller
\end_layout

\begin_layout Standard
Nonostante all'interno del 
\series bold
Datapath
\series default
 si abbiano tutte le informazioni necessarie alla visualizzazione del gioco
 mediante la porta VGA, abbiamo scelto di realizzare un componente separato
 che si occupi solamente di tale scopo: la 
\series bold
View
\series default
.
 
\end_layout

\begin_layout Standard
In questo modo si sfrutta il 
\emph on
design pattern
\emph default
 
\series bold
MVC (Model View Controller)
\series default
, nel quale i tre componenti hanno responsabilità separate, favorendo la
 modularità del progetto globale e rendendolo più facilmente estendibile
 e manutenibile.
 
\end_layout

\begin_layout Standard
Di conseguenza avremo 3 macrocomponenti:
\end_layout

\begin_layout Itemize

\series bold
Datapath (detto anche Model)
\series default
: conterrà la cosiddetta 
\begin_inset Quotes fld
\end_inset


\emph on
logica applicativa
\emph default

\begin_inset Quotes frd
\end_inset

, ovvero le operazioni che realizzeranno le funzionalità operative dell'applicaz
ione
\end_layout

\begin_layout Itemize

\series bold
View: 
\series default
sarà utilizzata per mostrare a video i contenuti del modello; dovrà quindi
 implementare i meccanismi per disegnare 
\begin_inset Quotes fld
\end_inset

pixel per pixel
\begin_inset Quotes frd
\end_inset

 l'intera griglia di gioco e per la gestione del 
\emph on
protocollo di comunicazione 
\series bold
\emph default
VGA
\series default
.
 È un osservatore passivo e non influenza il 
\emph on
modello
\emph default
 in alcun modo
\end_layout

\begin_layout Itemize

\series bold
Control Unit (detta anche Controller)
\series default
: riceverà tutti gli input dell'utente e dovrà gestire i relativi eventi,
 decidendo cosa debba fare il 
\emph on
modello
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MVC.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Pattern Model View Controller
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Gestione dell'I/O
\end_layout

\begin_layout Standard
Come si può vedere in 
\noun on
Figura 3.2
\noun default
, oltre ai tre sopracitati componenti che descrivono 
\emph on
Model, View e Controller
\emph default
, il nostro progetto dovrà comprendere inoltre anche i due moduli per la
 gestione dell'
\emph on
Input
\emph default
 da 
\series bold
tastiera
\series default
 e dell'
\emph on
Output
\emph default
 su 
\series bold
monitor
\series default
 e sui quattro 
\series bold
display 7 segmenti
\series default
.
\end_layout

\begin_layout Subsection
Interfaccia PS/2 (INPUT)
\end_layout

\begin_layout Standard
In questa sezione ci occuperemo di descrivere nel dettaglio come abbiamo
 realizzato il componente ausiliario interfacciato direttamente con la porta
 
\series bold
PS/2
\series default
, per la gestione dell'input da tastiera.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/ps2_interface.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Interfaccia PS/2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Protocollo
\end_layout

\begin_layout Standard
Il 
\series bold
PS/2
\series default
 è un protocollo 
\emph on
seriale, sincrono e bidirezionale
\emph default
 sviluppato dall’IBM e ampiamente usato al giorno d’oggi per far comunicare
 PC con tastiere e mouse.
\end_layout

\begin_layout Standard
La scheda 
\series bold
DE1
\series default
 ha in dotazione una porta PS/2 a 6-pin 
\noun on
Mini-DIN
\noun default
; per le porte PS/2 esiste anche un altro connettore, il 5-pin 
\noun on
Mini-DIN
\noun default
 (
\emph on
AT/XT
\emph default
): i due connettori sono (dal punto di vista elettrico) perfettamente compatibil
i (il protocollo è sempre il PS/2, l’unica differenza sta nella disposizione
 dei pin), per cui nel caso si possedesse una tastiera con connettore a
 5-pin è sufficiente l’uso di un adattatore.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/ATXT-PS2.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Differenze AT/XT - PS/2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Come si può capire dalle figure precedenti, tutta la comunicazione si basa
 su un 
\emph on
bus formato da 
\series bold
due
\series default
 linee bidirezionali
\emph default
: la linea di 
\series bold
clock
\series default
 e la linea 
\series bold
dati
\series default
.
 
\end_layout

\begin_layout Standard
Il bus è in uno stato di attesa quando le due linee di clock e di dati sono
 in uno stato logico alto: questo è l’unico stato nel quale è permesso alla
 tastiera trasmettere dati.
 L’host (che nel nostro caso è appunto la board) ha sempre il controllo
 finale sul bus e può in ogni momento inibire la comunicazione mettendo
 a massa la linea di clock; alla tastiera invece (
\emph on
e solo a lei
\emph default
) spetta il compito di 
\series bold
generare il clock
\series default
.
\end_layout

\begin_layout Subsubsection
La Tastiera
\end_layout

\begin_layout Standard
La tastiera consiste in una 
\emph on
matrice di tasti
\emph default
 ciascuno dei quali viene monitorato da un processore interno alla tastiera.
 
\end_layout

\begin_layout Standard
Ogni tastiera possiede un processore specifico (diverso dagli altri in base
 alle caratteristiche della tastiera), ma tutti quanti i processori fanno
 sostanzialmente lo stesso lavoro: controllano quale tasto viene premuto/rilasci
ato e spediscono all’host il dato appropriato; all’occorrenza si occupano
 di bufferizzare i dati se la linea di comunicazione risulta occupata.
\end_layout

\begin_layout Standard
Il 
\emph on

\begin_inset Quotes fld
\end_inset

pacchetto di informazioni
\emph default

\begin_inset Quotes frd
\end_inset

 trasmesso dalla tastiera all'host viene chiamato 
\series bold
Scan Code
\series default
.
 
\end_layout

\begin_layout Subsubsection
Scan code
\end_layout

\begin_layout Standard
Esistono due tipi di 
\emph on
scan codes
\emph default
: 
\end_layout

\begin_layout Itemize

\series bold
Make codes
\series default
: vengono spediti quando un tasto è premuto o viene tenuto premuto
\end_layout

\begin_layout Itemize

\series bold
Break codes
\series default
: utilizzati quando un tasto è rilasciato, nel nostro caso è sempre 
\begin_inset Quotes fld
\end_inset


\series bold
F0
\series default

\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard

\series bold
Ogni tasto è associato ad un unica coppia 
\begin_inset Quotes fld
\end_inset

make code / break code
\series default

\begin_inset Quotes frd
\end_inset

, in tal modo l’host può determinare esattamente cos'è successo e a che
 tasto semplicemente guardando il singolo scan code.
 Il set di 
\emph on
make e break code
\emph default
 per ogni tasto forma quello che viene chiamato 
\series bold
scan code set
\series default
.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename img/keyboard.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Scan code set
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Comunicazione
\end_layout

\begin_layout Standard
Come visto precedentemente, i due pins della scheda per la comunicazione
 sono 
\series bold
PS2_CLK
\series default
 (il clock della periferica collegata) e 
\series bold
PS2_DAT
\series default
 (attraverso il quale arrivano le informazioni).
 
\end_layout

\begin_layout Standard
La comunicazione avviene in modo 
\emph on
seriale
\emph default
, infatti PS2_DAT permette la trasmissione di un singolo bit alla volta,
 per questo motivo occorre predisporre un apposito modulo che gestisca il
 flusso di bit in ingresso, dando in uscita pacchetti contenenti le informazioni
 in modo ordinato.
\end_layout

\begin_layout Standard
Il componente da noi creato, che si occupa di ricostruire lo 
\series bold
Scan Code
\series default
 contiene un 
\bar under
contatore da 0 a 10
\bar default
: ogni singolo messaggio inviato dalla tastiera conterrà:
\end_layout

\begin_layout Itemize
un 
\emph on
bit di start
\emph default
, posto sempre a 0
\end_layout

\begin_layout Itemize
la 
\emph on
codifica del dato
\emph default
, ordinati dal meno significativo
\end_layout

\begin_layout Itemize
un
\emph on
 bit di parità
\end_layout

\begin_layout Itemize
un 
\emph on
bit di fine messaggio
\emph default
, posto sempre a 1
\end_layout

\begin_layout Standard
La nostra interfaccia dovrà quindi leggere gli 
\emph on
11 bit e costruire il dato a 8 bit desiderato
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/keyboard_timings.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Comunicazione Tastiera → Board 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Il Componente 
\begin_inset Quotes fld
\end_inset

Tastiera
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Nel nostro progetto abbiamo deciso di realizzare un singolo componente che
 comunichi direttamente con la 
\emph on
porta PS/2
\emph default
, lasciando alla 
\series bold
Control Unit 
\series default
solo il compito di riconoscere gli 
\series bold
scan codes 
\series default
ed agire di conseguenza.
 In particolare, il modulo emette la codifica ricevuta serialmente dalla
 tastiera fino alla ricezione del 
\series bold
break code
\series default
, continuando ad emettere quindi 
\begin_inset Quotes fld
\end_inset


\series bold
F0
\series default

\begin_inset Quotes frd
\end_inset

 fino alla ricezione di un nuovo codice.
\end_layout

\begin_layout Standard
Di seguito riportiamo la parte di codice realizzata per la gestione della
 comunicazione Tastiera → Board (vedi 
\noun on
Figura 3.6
\noun default
)
\end_layout

\begin_layout LyX-Code
Keyboard : process(keyboardClock) begin 
\end_layout

\begin_deeper
\begin_layout LyX-Code
if falling_edge(keyboardClock) 
\end_layout

\begin_layout LyX-Code
then
\end_layout

\begin_deeper
\begin_layout LyX-Code
-- bit di start
\end_layout

\begin_layout LyX-Code
if (bitCount = 0 and keyboardData = '0')
\end_layout

\begin_layout LyX-Code
then 
\end_layout

\begin_deeper
\begin_layout LyX-Code
scanCodeReady <= '0'; 
\end_layout

\begin_layout LyX-Code
bitCount <= bitCount + 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code
-- data
\end_layout

\begin_layout LyX-Code
elsif (bitCount > 0 and bitCount < 9)
\end_layout

\begin_layout LyX-Code
then 
\end_layout

\begin_deeper
\begin_layout LyX-Code
-- si shifta di un bit lo scancode da sinistra
\end_layout

\begin_layout LyX-Code
scancode <= keyboardData & scancode(7 downto 1); 
\end_layout

\begin_layout LyX-Code
bitCount <= bitCount + 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code
-- bit di parità 
\end_layout

\begin_layout LyX-Code
elsif (bitCount = 9)
\end_layout

\begin_layout LyX-Code
then
\end_layout

\begin_deeper
\begin_layout LyX-Code
bitCount <= bitCount + 1;
\end_layout

\end_deeper
\begin_layout LyX-Code
-- fine messaggio 
\end_layout

\begin_layout LyX-Code
elsif (bitCount = 10) 
\end_layout

\begin_layout LyX-Code
then
\end_layout

\begin_deeper
\begin_layout LyX-Code
scanCodeReady <= '1';
\end_layout

\begin_layout LyX-Code
bitCount <= 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
end if;
\end_layout

\end_deeper
\begin_layout LyX-Code
end if;
\end_layout

\end_deeper
\begin_layout LyX-Code
end process Keyboard;
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Interfaccia VGA (OUTPUT)
\end_layout

\begin_layout Standard
In questa sezione ci occuperemo di descrivere nel dettaglio come abbiamo
 realizzato il componente ausiliario interfacciato direttamente con la porta
 
\series bold
VGA
\series default
, per la gestione dell'output a video.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_interface.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Interfaccia VGA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Protocollo
\end_layout

\begin_layout Standard
Il 
\series bold
VGA
\series default
 (
\emph on
Video Graphics Array
\emph default
) è uno standard analogico introdotto da IBM alla fine degli anni '80, comunemen
te impiegato nella visualizzazione di immagini a display da parte di computers.
 
\end_layout

\begin_layout Standard
Concepito inizialmente come singolo chip allo scopo di sostituire altri
 standard e hardware preesistenti sul mercato, con il passare del tempo
 si è imposto come standard universalmente riconosciuto per il pilotaggio
 di display, tanto da essere impiegato anche attualmente: le schede grafiche
 presenti sul mercato devono essere almeno in grado di gestire lo schermo
 con lo 
\emph on
standard VGA
\emph default
, prima che venga effettuato il boot del sistema operativo e quindi caricato
 il driver specifico di ogni scheda.
\end_layout

\begin_layout Standard
La connessione VGA standard termina con uno spinotto maschio a 15-pin, il
 cui pinout è mostrato in 
\noun on
Figura 3.8
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_pinout.jpg

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Pinout VGA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Come si evince dalla figura precedente, lo standard video VGA prevede 
\series bold
5 segnali attivi
\series default
: 
\end_layout

\begin_layout Itemize

\series bold
\color red
Rosso (
\emph on
Red
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore rosso sullo schermo (
\emph on
pin 1
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color green
Verde (
\emph on
Green
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore verde sullo schermo (
\emph on
pin 2
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color blue
Blu (
\emph on
Blue
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore blu sullo schermo (
\emph on
pin 3
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color magenta
Sincronismo orizzontale (
\emph on
H Sync
\emph default
)
\series default
\color inherit
: usato per la sincronizzazione del video (
\emph on
pin 13
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color magenta
Sincronismo verticale (
\emph on
V Sync
\emph default
)
\series default
\color inherit
: usato per la sincronizzazione del video (
\emph on
pin 14
\emph default
)
\end_layout

\begin_layout Standard
Lo schermo viene diviso in pixel ed il colore di ciascuno di essi è determinato
 dal valore di tensione del segnale 
\series bold
\color red
R
\color green
G
\color blue
B
\series default
\color inherit
.
 Se un certo 
\emph on

\begin_inset Quotes fld
\end_inset

canale colore
\emph default

\begin_inset Quotes frd
\end_inset

 viene pilotato a valore minimo di tensione, si ha che tale colore non viene
 visualizzato a schermo in corrispondenza di quel particolare pixel (
\emph on
colore spento
\emph default
), mentre se lo stesso 
\begin_inset Quotes fld
\end_inset


\emph on
canale colore
\emph default

\begin_inset Quotes frd
\end_inset

 viene pilotato a 
\bar under
tensione massima
\bar default
, si ha la 
\bar under
massima brillantezza possibile
\bar default
 di quel determinato colore per quel particolare pixel.
 
\end_layout

\begin_layout Standard
Solitamente viene assegnato a ciascuno dei segnali colore (
\series bold
RGB
\series default
) un certo numero di bit, il cui valore, attraverso un semplice 
\emph on
convertitore digitale analogico resistivo
\emph default
 (
\noun on
Figura 3.7
\noun default
), ne determina il livello di tensione che andrà poi a colorare i pixel
 a schermo.
 Nel nostro caso si utilizzano 
\bar under
4 bit per colore
\bar default
, per un totale di 
\bar under
12 bit di codifica
\bar default
 per un singolo 
\emph on
colore RGB
\emph default
: questo rende possibili 
\series bold
4096
\series default
 
\bar under
tonalità di colori
\end_layout

\begin_layout Standard
I segnali di 
\series bold
sincronismo orizzontale e verticale
\series default
 sono segnali interamente digitali, compatibili con i livelli della 
\emph on
logica TTL.
\end_layout

\begin_layout Subsubsection
VGA Mode
\end_layout

\begin_layout Standard
Per operare in 
\emph on
VGA mode
\emph default
, occorre avere 
\series bold
640x480
\series default
 pixel, 
\series bold
25Mhz
\series default
 di dot clock (ovvero il 
\emph on
periodo di clock per disegnare un singolo pixel
\emph default
) e un 
\series bold
refresh
\series default
 dei frame di 
\series bold
60Hz
\series default
 (ossia la 
\emph on
frequenza di aggiornamento dell’intera immagine
\emph default
).
 La visualizzazione avviene per righe: per disegnare la nostra griglia di
 gioco pixel per pixel, ci serviamo di due contatori, 
\emph on
h_cnt
\emph default
 e 
\emph on
v_cnt
\emph default
, che tengono traccia delle coordinate del punto che stiamo rappresentando
 attualmente, incrementando prima il contatore orizzontale, quindi, al raggiungi
mento della fine della riga, quello verticale.
 
\end_layout

\begin_layout Standard
I valori dei due contatori vengono anche sfruttati per generare i segnali
 di sincronizzazione 
\emph on
h_sync
\emph default
 e 
\emph on
v_sync
\emph default
.
\end_layout

\begin_layout Standard
Una volta 
\begin_inset Quotes fld
\end_inset

terminata
\begin_inset Quotes frd
\end_inset

 una singola riga, occorre attendere un tempo di latenza dovuto a specifiche
 tecniche, detto 
\series bold
Front Porch
\series default
, per poi passare alla riga successiva (incrementando quindi il contatore
 verticale 
\emph on
v_cnt
\emph default
), fino al raggiungimento dell’ultima riga; a sua volta, la nuova riga dovrà
 rispettare un tempo di attesa, definito 
\series bold
Back Porch
\series default
, prima di inviare correttamente i dati.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_diagrams.jpg
	scale 60

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Diagrammi temporali dei segnali di sincronismo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Verranno riportate ora le specifiche temporali del 
\emph on
VGA mode
\emph default
 per spiegare un po' meglio quanto appena detto.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_timings.png
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Specifiche temporali VGA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Un impulso attivo basso di durata 
\noun on
a
\noun default
 viene applicato al segnale di sincronismo orizzontale della porta VGA;
 tale periodo determina 
\emph on
una riga di dati
\emph default
.
 
\end_layout

\begin_layout Standard
\noindent
L'ingresso RGB del monitor dev'essere pilotato a 0 Volt durante il 
\series bold
back porch
\series default
 dopo l'arrivo dell'impulso 
\emph on
h_sync
\emph default
.
 
\end_layout

\begin_layout Standard
\noindent
Successivamente, nel periodo 
\noun on
c
\noun default
 viene disegnato sull’uscita ogni singolo pixel relativo a quella linea;
 infine si attende ancora il tempo 
\noun on
d
\noun default
, ovvero durante il 
\series bold
front porch
\series default
, dove il segnale RGB è ancora una volta pilotato a 0 Volt in attesa del
 successivo 
\emph on
h_sync
\emph default
.
 Il grafico della sincronia verticale è il medesimo solamente che l'arrivo
 del 
\emph on
v_sync
\emph default
 significa la fine di un frame e l'inizio del successivo.
\end_layout

\begin_layout Subsubsection
Realizzazione in VHDL
\end_layout

\begin_layout Standard
Come anticipato, abbiamo un contatore orizzontale 
\emph on
h_cnt
\emph default
 che varia da 0 a 799, un intervallo di valori corrispondente al periodo
 totale della linea, cioè 31,7 µs (
\noun on
a+b+c+d
\noun default
 nella tabella); il segnale 
\emph on
h_sync
\emph default
 si mantiene alto per 
\emph on
h_cnt
\emph default
 che varia tra 0 e 658, viene posto a '0' quando 
\emph on
h_cnt
\emph default
 assume valori compresi tra 659 e 755, poi viene nuovamente settato a '1'
 fino a 799.
\end_layout

\begin_layout Standard
Si inizializza il contatore a 0 nel momento dell’inizio del 
\series bold
Display Time
\series default
 (vedi 
\noun on
figura 3.9
\noun default
), spostando 
\emph on
back porch
\emph default
 dopo il 
\emph on
front porch
\emph default
.
 In questo modo il funzionamento del sincronismo non cambia, ma permette
 di leggere direttamente in 
\emph on
h_cnt
\emph default
 il valore della colonna attuale.
\end_layout

\begin_layout Standard
In maniera analoga avviene per quanto riguarda la sincronia verticale, in
 particolare 
\emph on
v_cnt
\emph default
 varia da 0 a 524, un intervallo di valori corrispondente al periodo totale
 della schermata, cioè 16,6 ms (60Hz di frequenza); il segnale 
\emph on
v_sync
\emph default
 si mantiene alto per 
\emph on
v_cnt
\emph default
 che varia tra 0 e 492, viene posto a '0' quando 
\emph on
v_cnt
\emph default
 assume i valori 493 e 494, poi viene nuovamente settato a '1' fino a 524.
 
\end_layout

\begin_layout Standard
Esiste un ulteriore segnale interno, 
\emph on
video_en
\emph default
, attivo solo se 
\emph on
h_cnt
\emph default
 è minore di 640 e 
\emph on
v_cnt
\emph default
 è minore di 480, ovvero solo durante il 
\series bold
Display Time
\series default
; pertanto l’informazione sul colore del pixel viene ricopiata dall'ingresso
 all'uscita solo quando 
\emph on
video_en
\emph default
 è settato a '1', cioè solo se ci si trova all'interno dello schermo attivo.
\end_layout

\begin_layout LyX-Code
-- Reset Horizontal Counter
\end_layout

\begin_layout LyX-Code
IF (h_cnt = 799)
\end_layout

\begin_layout LyX-Code
THEN
\end_layout

\begin_deeper
\begin_layout LyX-Code
h_cnt := 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSE
\end_layout

\begin_deeper
\begin_layout LyX-Code
h_cnt := h_cnt + 1;
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF;
\end_layout

\begin_layout LyX-Code
-- H_SYNC
\end_layout

\begin_layout LyX-Code
IF (h_cnt <= 755 AND h_cnt >= 659)
\end_layout

\begin_layout LyX-Code
THEN
\end_layout

\begin_deeper
\begin_layout LyX-Code
h_sync := '0';
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSE
\end_layout

\begin_deeper
\begin_layout LyX-Code
h_sync := '1';
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF; 
\end_layout

\begin_layout LyX-Code
-- Reset Vertical Counter
\end_layout

\begin_layout LyX-Code
IF (v_cnt >= 524 AND h_cnt >= 699)
\end_layout

\begin_layout LyX-Code
THEN
\end_layout

\begin_deeper
\begin_layout LyX-Code
v_cnt := 0;
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSIF (h_cnt = 699) 
\end_layout

\begin_layout LyX-Code
THEN
\end_layout

\begin_deeper
\begin_layout LyX-Code
v_cnt := v_cnt + 1;
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF;
\end_layout

\begin_layout LyX-Code
-- V_SYNC
\end_layout

\begin_layout LyX-Code
IF (v_cnt = 490 OR v_cnt = 491) 
\end_layout

\begin_layout LyX-Code
THEN 
\end_layout

\begin_deeper
\begin_layout LyX-Code
v_sync := '0';
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSE
\end_layout

\begin_deeper
\begin_layout LyX-Code
v_sync := '1';
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF; 
\end_layout

\begin_layout LyX-Code
-- Horizontal Data Enable 
\end_layout

\begin_layout LyX-Code
IF (h_cnt <= 639) 
\end_layout

\begin_layout LyX-Code
THEN 
\end_layout

\begin_deeper
\begin_layout LyX-Code
horizontal_en := '1';
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSE 
\end_layout

\begin_deeper
\begin_layout LyX-Code
horizontal_en := '0';
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF; 
\end_layout

\begin_layout LyX-Code
-- Vertical Data Enable 
\end_layout

\begin_layout LyX-Code
IF (v_cnt <= 479)
\end_layout

\begin_layout LyX-Code
THEN 
\end_layout

\begin_deeper
\begin_layout LyX-Code
vertical_en := '1';
\end_layout

\end_deeper
\begin_layout LyX-Code
ELSE 
\end_layout

\begin_deeper
\begin_layout LyX-Code
vertical_en := '0';
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF; 
\end_layout

\begin_layout LyX-Code
-- Video Enable 
\end_layout

\begin_layout LyX-Code
video_en := horizontal_en AND vertical_en;
\end_layout

\begin_layout Subsection
Interfaccia 7 Segmenti (OUTPUT)
\end_layout

\begin_layout Standard
L'ultimo componente ausiliario, utilizzato dalla 
\emph on
View
\emph default
 è il controllore dei quattro 
\series bold
Display a 7 segmenti
\series default
 della board, utilizzato per visualizzare il punteggio corrente raggiunto
 nella partita.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/7segment_interface.png
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Interfaccia Display 7 Segmenti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Applicando un livello logico basso fa sì che un segmento si illumini, mentre
 applicando un livello logico alto lo si spegne: lavora quindi in logica
 negativa.
\end_layout

\begin_layout Standard
Ciascun segmento di ogni 
\series bold
Display
\series default
 è identificato tramite un indice da 0 a 6, con le posizioni indicate nella
 
\noun on
Figura 3.1
\noun default
2; si noti dallo schema logico di 
\noun on
Figura 3.11
\noun default
 che il punto in ciascun display è 
\emph on
scollegato
\emph default
 e pertanto 
\bar under
non può essere utilizzato
\bar default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/position-index.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Posizione e indice di ciascun segmento in un Display 7 segmenti
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Realizzazione in VHDL
\end_layout

\begin_layout Standard
Il componente da noi realizzato, gestito dalla 
\emph on
View
\emph default
, prende in ingresso un intero compreso tra 0 e 9999 (ovvero il range di
 valori rappresentabili tramite i 4 display a 7 segmenti) e restituisce
 i quattro vettori logici che controllano ciascuno i 7 segmenti di ogni
 display.
 Vediamo il frammento di codice nel dettaglio:
\end_layout

\begin_layout LyX-Code
numChange : process(num)
\end_layout

\begin_deeper
\begin_layout LyX-Code
variable digit4, digit3, digit2, digit1 : integer range 0 to 9;
\end_layout

\end_deeper
\begin_layout LyX-Code
begin 
\end_layout

\begin_deeper
\begin_layout LyX-Code
splitNumber(num, digit4, digit3, digit2, digit1); 	
\end_layout

\begin_layout LyX-Code
seven_segs4 <= digit_to_7seg(digit4);
\end_layout

\begin_layout LyX-Code
seven_segs3 <= digit_to_7seg(digit3); 
\end_layout

\begin_layout LyX-Code
seven_segs2 <= digit_to_7seg(digit2); 
\end_layout

\begin_layout LyX-Code
seven_segs1 <= digit_to_7seg(digit1); 
\end_layout

\end_deeper
\begin_layout LyX-Code
end process numChange;
\end_layout

\begin_layout Standard
Come si può vedere, abbiamo creato la funzione 
\begin_inset Quotes fld
\end_inset


\emph on
splitNumber
\emph default

\begin_inset Quotes frd
\end_inset

 che suddivide il numero nelle sue quattro cifre, ognuna delle quali verrà
 convertita nella opportuna combinazione di segmenti che la riproduce sul
 display, tramite la funzione 
\begin_inset Quotes fld
\end_inset


\emph on
digit_to_7seg
\emph default

\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsection
Divisore di Frequenza
\end_layout

\begin_layout Standard
Avendo a disposizione solo clock a 50 e 27Mhz, siamo stati obbligati a realizzar
e un componente che dividesse la frequenza per 2, per ottenere in uscita
 un clock a 
\series bold
25Mhz
\series default
 da utilizzare per tutti i dispositivi del progetto.
\end_layout

\begin_layout Standard
Il modo più semplice per ottenere un 
\emph on
divisore di frequenza
\emph default
 è quello di realizzare un contatore che fornisca un segnale in uscita solamente
 per alcuni valori: nel nostro caso particolare è stato sufficiente un contatore
 a 1 bit: se il contatore conta ogni fronte di salita (o, volendo, di discesa)
 infatti, otteniamo già un clock a frequenza dimezzata.
\end_layout

\begin_layout LyX-Code
ARCHITECTURE Behavioral OF GAME_CLKGENERATOR IS
\end_layout

\begin_deeper
\begin_layout LyX-Code
SIGNAL counter : STD_LOGIC_VECTOR(0 DOWNTO 0);
\end_layout

\end_deeper
\begin_layout LyX-Code
BEGIN
\end_layout

\begin_deeper
\begin_layout LyX-Code
PROCESS (clock)
\end_layout

\begin_layout LyX-Code
BEGIN
\end_layout

\begin_deeper
\begin_layout LyX-Code
IF (clock = '0' AND clock'event)
\end_layout

\begin_layout LyX-Code
THEN
\end_layout

\begin_deeper
\begin_layout LyX-Code
counter <= counter + 1; 
\end_layout

\end_deeper
\begin_layout LyX-Code
END IF;
\end_layout

\end_deeper
\begin_layout LyX-Code
END PROCESS; 
\end_layout

\begin_layout LyX-Code
half_clock <= counter(0);
\end_layout

\end_deeper
\begin_layout LyX-Code
END Behavioral;
\end_layout

\begin_layout Section
Implementazione del Modello (Datapath)
\end_layout

\begin_layout Standard
Come già detto precedentemente la realizzazione del componente 
\series bold
Model
\series default
 del design 
\emph on
pattern MVC
\emph default
 sarà un punto critico per la realizzazione di questo progetto.
 Per questo motivo abbiamo deciso di affrontare questo argomento prima della
 realizzazione delle altre parti.
\end_layout

\begin_layout Standard
All’interno del 
\emph on
Datapath
\emph default
 è presente la la 
\bar under
struttura del modello
\bar default
 e logica relativa alle 
\bar under
regole del gioco
\bar default
, ovvero le azioni che verranno eseguite sul modello: viene gestito il 
\series bold
movimento 
\series default
delle celle, il loro 
\series bold
merging
\series default
, ovvero l'unione delle celle di valore uguale quando queste si scontrano,
 l'aggiunta in una posizione casuale di una
\series bold
 nuova cella
\series default
, l'aggiornamento del 
\series bold
punteggio
\series default
 e degli 
\series bold
stati
\series default
 del gioco, che spiegheremo più approfonditamente nei nei prossimi paragrafi.
\end_layout

\begin_layout Subsection
Struttura del modello
\end_layout

\begin_layout Subsubsection
Griglia di gioco
\end_layout

\begin_layout Standard
Analizzando il gioco, abbiamo notato che per ogni singolo instante della
 partita avremo la necessità di rappresentare lo stato delle 
\series bold
16 caselle
\series default
 (
\emph on
4x4
\emph default
) che compongono la 
\begin_inset Quotes fld
\end_inset


\emph on
scacchiera
\emph default

\begin_inset Quotes frd
\end_inset

.
 Ogni singola cella è rappresentata quindi da un valore numerico compreso
 tra 
\series bold
0
\series default
 e 
\series bold
2048
\series default
.
 Per poter mantenere lo stato attuale del gioco si è quindi scelto di utilizzare
 una matrice 4x4 di interi, ognuno rappresentante, appunto, il valore attuale
 della propria 
\series bold
cella
\series default
.
 Di seguito, la rappresentazione in 
\emph on
VHDL
\emph default
.
\end_layout

\begin_layout LyX-Code
constant GRID_WIDTH  : INTEGER RANGE 0 to 7 := 4; 
\end_layout

\begin_layout LyX-Code
constant GRID_HEIGHT : INTEGER RANGE 0 to 7 := 4; 
\end_layout

\begin_layout LyX-Code
type GAME_GRID is array (GRID_HEIGHT-1 downto 0, GRID_WIDTH -1 downto 0)
 of integer range 0 to 4000;
\end_layout

\begin_layout Standard
Le 
\series bold
celle vuote
\series default
 del gioco vengono gestite semplicemente considerando le celle con 
\emph on
valore 0
\emph default
, che non verranno mostrate a livello di interfaccia grafica, come nel gioco
 originale, ma questo accorgimento sarà implementato solo a livello di 
\emph on
View
\emph default
.
\end_layout

\begin_layout Subsubsection
Punteggio della partita
\end_layout

\begin_layout Standard
Ulteriormente allo stato corrente della griglia di gioco, sarà necessario
 mantenere informazioni riguardo il punteggio attuale, rappresentabile con
 un singolo 
\emph on
intero
\emph default
.
 
\end_layout

\begin_layout Subsubsection
FSM del gioco
\end_layout

\begin_layout Standard
Gli stati che occorrerà considerare sono quattro:
\end_layout

\begin_layout Itemize

\series bold
Stato iniziale
\series default
, ovvero all'inizio della partita viene inizializzata la matrice con due
 celle casuali dal valore 2 (
\emph on
bootstrap
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
Gioco normale
\series default
, ovvero la fase dove l'utente può eseguire normalmente tutte le mosse (
\emph on
playing
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
Vittoria
\series default
, ovvero la creazione di una cella dal valore di 
\series bold
2048 
\series default
(
\emph on
victory
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
Sconfitta
\series default
, ovvero l'impossibilità per il giocatore di effettuare ulteriori mosse
 sulla griglia di gioco (
\emph on
gameover
\emph default
)
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/FSM_game.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
FSM del gioco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Azioni sul modello
\end_layout

\begin_layout Standard
Avendo stabilito quale sia la rappresentazione dello stato, ora, serve comprende
re quali sono le azioni che il nostro modello deve poter compiere per poter
 modificare lo stato in risposta all'
\emph on
input
\emph default
 inviato dall'utente.
 Il gioco prevede i movimenti nelle 
\series bold
4 direzioni
\series default
 (
\noun on
Su, Giù, Destra, Sinistra
\noun default
), che corrispondono ai comandi con cui il giocatore può interagire con
 il gioco, e ognuno di questi movimenti comporta una serie di eventi in
 cascata:
\end_layout

\begin_layout Enumerate
Una volta che viene impartita la direzione, la prima fase che si considera
 è la cosiddetta fase di 
\series bold
merging
\series default
, ovvero le caselle adiacenti contenenti lo stesso valore numerico lungo
 la direzione impartita, vengono 
\begin_inset Quotes fld
\end_inset


\emph on
fuse
\emph default

\begin_inset Quotes frd
\end_inset

 in un'unica singola cella contenente come nuovo valore la somma delle due
 caselle generatrici.
 Questo procedimento viene eseguito prima della fase successiva di movimento
 e viene definita come fase di 
\series bold
MERGE
\series default
.
\end_layout

\begin_layout Enumerate
Le celle vengono 
\series bold
traslate
\series default
 dalla propria posizione iniziale verso la cella massima libera raggiungibile
 nella direzione d'ingresso.
 In altre parole, supponiamo che l'utente abbia selezionato la 
\emph on
direzione destra
\emph default
: il gioco deve controllare per ogni n-esima cella se la propria cella adiacente
 (verso destra) sia libera, in caso positivo essa dovrà 
\begin_inset Quotes fld
\end_inset


\emph on
spostarsi
\emph default

\begin_inset Quotes frd
\end_inset

 nella direzione specificata.
 Questa viene definita come fase di 
\series bold
MOVE
\series default
.
\end_layout

\begin_layout Enumerate
L'ultima azione prevista al termine del 
\series bold
merge-move
\series default
 consiste nell'
\bar under
aggiunta di una nuova cella
\bar default
 contenente il valore 
\series bold
2
\series default
 in una posizione casuale libera della griglia di gioco.
\end_layout

\begin_layout Subsection
FSM della logica delle azioni
\end_layout

\begin_layout Standard
Dal paragrafo precedente 3.3.2, abbiamo cominciato a comprendere quali sono
 in termini generali le caratteristiche del gioco.
 A questo punto per poter scrivere del codice sarà necessario razionalizzare
 quanto già detto precedentemente e schematizzarlo in maniera chiara.
 
\end_layout

\begin_layout Standard
Il gioco ha delle regole ben fisse e questo comporta anche delle dimensioni
 della scacchiera non variabili, ovvero 
\series bold
4x4
\series default
.
 
\end_layout

\begin_layout Standard
É stato quindi necessario utilizzare 
\emph on
3 stati di merge
\emph default
 e 
\emph on
3 stati di move
\emph default
; ovvero, per ogni riga e/o per ogni colonna saranno possibili solamente
 3 movimenti e/o merge per ogni input inviato dall'utente.
 Quindi in ordine, dovremo prima controllare che sia possibile fare il merge
 e poi verificare la possibilità di fare un movimento, questo per 3 volte,
 in maniera da essere sicuri di aver tenuto conto di tutte le conseguenze
 dell'input.
 Infatti dalle regole del gioco ogni cella deve tentare di spostarsi fino
 a dove è possibile quindi ad una direzione non corrisponde una sola azione
 di merge e/o di move, ma al massimo 3.
\end_layout

\begin_layout Standard
Quindi riassumendo gli stati che abbiamo rilevato precedentemente:
\end_layout

\begin_layout Itemize

\series bold
init
\series default
: si predispone la griglia di gioco per una nuova partita, ovvero si colloca
 un 2 in una cella casuale (in realtà le celle generate saranno due, perchè
 prima di arrivare allo stato di 
\emph on
idle
\emph default
, passa subito nello stato 
\emph on
randupdate
\emph default
, spiegato tra poche righe)
\end_layout

\begin_layout Itemize

\series bold
idle
\series default
: in questo stato il sistema è in attesa di ricevere un input dall'utente,
 ovvero una delle 4 mosse effettuabili; questo stato ha un autoanello perchè
 finchè non viene ricevuta una mossa, il sistema continuerà ad aggiornarsi
 nello stesso stato corrente
\end_layout

\begin_layout Itemize

\series bold
merge1
\series default
: vengono prima controllate le coppie di celle esterne a 2 a 2 che se sono
 uguali vengono unificate, poi solo quelle più vicine alla parete nella
 direzione opposta alla direzione, dopodichè se anche queste non sono uguali
 viene verificata la coppia centrale e infine la coppia più vicina alla
 parete da cui proviene il movimento; questo viene verificato per tutte
 le righe se si sta effettuando un movimento orizzontale, oppure per tutte
 le colonne in caso di movimento verticale (
\noun on
Su, Giù
\noun default
); da qui ci si porta inevitabilmente allo stato 
\emph on
move1
\end_layout

\begin_layout Itemize

\series bold
move1
\series default
: in questo stato vengono semplicemente mosse le celle che possono muoversi
 lungo la direzione, in seguito alla fase di 
\emph on
merge1, 
\emph default
questo movimento porta inevitabilmente alla nuova fase di 
\emph on
merge2
\end_layout

\begin_layout Itemize

\series bold
merge2
\series default
: in questa fase vengono rieffettuati i controlli descritti in 
\emph on
merge1
\emph default
, perchè se la fase 
\emph on
move1 
\emph default
ha effettuato spostamenti validi, occorre riprovare l'unificazione delle
 celle: in questa fase non è possibile vengano unificate le celle più vicine
 alla parete da cui proviene il movimento, perchè sarebbero già state unificate
 nello stato di 
\emph on
merge1
\end_layout

\begin_layout Itemize

\series bold
move2
\series default
: come per lo stato 
\emph on
move1
\emph default
, si provano a muovere le celle che possono farlo, ovvero solo se la fase
 di 
\emph on
merge2 
\emph default
ha comportato dei merge
\end_layout

\begin_layout Itemize

\series bold
merge3
\series default
: in questa fase le uniche celle unificabili sono quelle centrali che possono
 essersi ritrovate unificabili in seguito alla seconda fase di movimento,
 perchè le altre possibili celle unificabili sono già state controllate
 nelle fasi precedenti
\end_layout

\begin_layout Itemize

\series bold
move3
\series default
: come per gli altri stati di move, si riprovano a muovere le celle che
 possono farlo se l'ultima fase di merge è riuscita a unificare le celle
 centrali
\end_layout

\begin_layout Itemize

\series bold
checkupdate
\series default
: in questo stato si controlla che la mossa effettuata dall'utente abbia
 modificato lo stato della griglia di gioco.
 Lo stato della matrice potrebbe restare invariato rispetto a quello precedente,
 in caso di movimenti che non comportino alcuna modifica reale (l'utente
 non ha ancora perso perchè può ancora compiere movimenti) e in questo caso
 
\emph on
la mossa non è da considerare come valida
\emph default
 e pertanto non si deve procedere all'aggiunta di una nuova cella: si ritorna
 direttamente nello stato di 
\emph on
idle
\emph default
 ed è quindi come se non fosse cambiato nulla in seguito alla mossa non
 valida
\end_layout

\begin_layout Itemize

\series bold
randupdate
\series default
: in questa fase viene aggiunta una nuova cella dal valore 2 in una posizione
 casuale tra le celle 
\begin_inset Quotes fld
\end_inset


\emph on
libere
\emph default

\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/FSM_moves.png
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
FSM delle azioni
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nonostante 
\series bold
Quartus II
\series default
 abbia reso un po' meno leggibile il diagramma della 
\emph on
FSM
\emph default
, accavallando alcuni stati vicini, si può notare come ogni mossa porti
 alla sequenza 
\emph on

\begin_inset Quotes fld
\end_inset

merge1 → move1 → merge2 → move2 → merge3 → move3 → checkupdate
\begin_inset Quotes frd
\end_inset

 
\emph default
che passerà per lo stato 
\emph on
randupdate 
\emph default
solo nel caso in cui la mossa verrà considerata valida.
\end_layout

\end_body
\end_document
