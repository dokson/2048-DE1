#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass book
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 3cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 1
\paperpagestyle default
\bullet 0 0 0 4
\bullet 1 0 8 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
2048 - VHDL su Altera DE1
\end_layout

\begin_layout Author
Alessandro Colace (0000700279) e Giacomo Gezzi (0000688447)
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Introduzione
\end_layout

\begin_layout Section
Storia
\end_layout

\begin_layout Standard

\series bold
2048
\series default
 è un videogioco a giocatore singolo pubblicato on-line il 9 marzo 2014
 da Gabriele Cirulli, uno sviluppatore web italiano di 19 anni, il cui obiettivo
 è quello di far scorrere le piastrelle su una griglia, unirle e creare
 una tessera con il numero 
\series bold
2048
\series default
.
 
\end_layout

\begin_layout Standard
Considerato come un rompicapo, è molto simile a 
\series bold
\emph on
Threes!
\series default
\emph default
, applicazione pubblicata un mese prima, ma versioni simili includono anche
 elementi provenienti da 
\emph on
Doge, Doctor Who, Flappy Bird e Tetris
\emph default
.
 
\end_layout

\begin_layout Standard
L'autore definisce questi cloni come 
\emph on

\begin_inset Quotes fld
\end_inset

La bellezza dei software open source
\emph default

\begin_inset Quotes frd
\end_inset

 e non si oppone a loro in quanto, dice, 
\emph on

\begin_inset Quotes fld
\end_inset

aggiungono nuove modifiche creative per il gioco
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Section
Meccanica del gioco
\end_layout

\begin_layout Standard
A 
\series bold
2048
\series default
 si gioca su una semplice griglia grigia di formato
\series bold
 4×4
\series default
 in cui scorrono caselle di 
\series bold
colori diversi
\series default
, con 
\series bold
numeri diversi
\series default
 (
\emph on
tutti i numeri sono potenze di 2
\emph default
), senza intralci quando un giocatore le muove.
 Il gioco usa i
\series bold
 tasti freccia della tastiera 
\series default
per spostare tutte le caselle 
\bar under
a sinistra o a destra oppure in alto o in basso
\bar default
.
 
\emph on
Se due caselle contenenti lo stesso numero si 
\series bold
scontrano
\series default
\emph default
 mentre si 
\series bold
\emph on
muovono
\series default
\emph default
, si 
\series bold
fondono in un'unica casella
\series default
 che avrà come numero la
\series bold
 somma delle due tessere che si sono scontrate
\series default
 e dunque il 
\series bold
colore corrispondente
\series default
.
 Ad ogni turno, un nuova tessera con il valore di 2 apparirà in modo casuale
 in un punto vuoto sul tabellone.
\end_layout

\begin_layout Standard
Inoltre, un tabellone in alto a destra tiene traccia del punteggio dell'utente.
 Il punteggio dell'utente inizia da zero e viene incrementato ogni volta
 che due tessere si combinano, con il valore della nuova casella.
\end_layout

\begin_layout Standard

\series bold
La partita è vinta
\series default
 quando, a furia di far combinare le tessere,
\series bold
 si riesce a crearne una con il numero 2048
\series default
: da qui il nome del gioco.
\end_layout

\begin_layout Standard
Se il giocatore 
\series bold
non può muovere le caselle
\series default
 (
\emph on
non ci sono spazi vuoti e senza tessere adiacenti con lo stesso valore
\emph default
), 
\series bold
finisce la partita
\series default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/2048_Screenshot.png
	scale 48

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Esempio della Schermata di Gioco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Colori delle caselle
\end_layout

\begin_layout Standard
Nel gioco, ogni numero è abbinato ad un colore differente.
 Tutti sono "colori caldi", ovvero colori derivati dal rosso, eccetto per
 il 2 che presenta una tonalità di grigio.
\end_layout

\begin_layout Standard
Il 4 presenta una tonalità beige mentre dall'8 al 64 i numeri sono abbinati
 a varie tonalità di rosso che variano dal mattone per l'8 al sangue per
 il 64.
\end_layout

\begin_layout Standard
Raggiunto il 128, i numeri tornano chiari, utilizzando la tonalità ocra
 fino al 2048: da un pallido giallo del 128, infatti le tonalità s'intensificano
 con il 256, il 512 e il 1024 sino a giungere il 2048 che è di colore ocra
 intenso/oro.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/colours.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Colori originali delle caselle del gioco
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Analisi
\end_layout

\begin_layout Section
Realizzazione di un prototipo
\end_layout

\begin_layout Standard
Il gioco originale è stato scritto in 
\series bold
JavaScript
\series default

\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://gabrielecirulli.github.io/2048/
\end_layout

\end_inset

, ma, avendo la necessità di iniziare un progetto utilizzando il codice
 
\series bold
VHDL
\series default
 
\emph on
da zero
\emph default
, abbiamo preferito riscriverci dapprima un piccolo prototipo in 
\series bold
JAVA
\series default
 in modo da riuscire a capire meglio il codice del gioco..
\end_layout

\begin_layout Standard
Abbiamo scelto 
\emph on
JAVA
\emph default
 per la familiarità con questo linguaggio di programmazione: in questo modo
 è stato più semplice fare svariati test in una fase preliminare e riuscire
 ad avere un quadro generale dello sviluppo, in vista del futuro utilizzo
 di 
\series bold
Quartus II 
\series default
di 
\emph on
Altera
\emph default
.
\end_layout

\begin_layout Section
VHDL
\end_layout

\begin_layout Standard
Il linguaggio scelto per descrivere l’architettura implementata è il 
\series bold
VHDL-93
\series default

\begin_inset Foot
status open

\begin_layout Plain Layout
http://it.wikipedia.org/wiki/VHDL
\end_layout

\end_inset

, per l’ampio utilizzo che se ne fa praticamente in tutta Europa per la
 progettazione hardware che lo porta ad essere uno standard di fatto in
 materia.
 
\end_layout

\begin_layout Standard
Il 
\series bold
VHDL
\series default
 è un linguaggio per la descrizione dell’hardware (
\emph on
Hardware Description Language
\emph default
), che può essere utilizzato per la documentazione, la simulazione e la
 sintesi di sistemi digitali.
 Inizialmente, nei primi anni ’80, lo sviluppo del VHDL è stato supportato
 dal dipartimento della difesa statunitense, nell’ambito di un progetto
 denominato 
\series bold
VHSIC
\series default
 (
\emph on
Very High Speed Integrated Circuits
\emph default
).
 
\end_layout

\begin_layout Standard
Il linguaggio è nato quindi con lo scopo di 
\series bold
fornire una descrizione non ambigua di un sistema digitale
\series default
, che potesse essere interpretata univocamente dai vari progettisti impegnati
 nello sviluppo del sistema stesso.
 Una delle caratteristiche richieste al VHDL è la possibilità di 
\emph on
simulare il sistema descritto
\emph default
, sia a livello funzionale sia 
\bar under
tenendo in considerazione tutte le non idealità che si hanno in un circuito
 reale
\bar default
.
 
\end_layout

\begin_layout Section
Altera DE1
\end_layout

\begin_layout Standard
Avendo a disposizione una scheda 
\series bold
Terasic DE1 
\series default
che monta 
\series bold
FPGA Cyclone II di ALTERA
\series default
, la quale mette a disposizione numerose features per sviluppare variegati
 progetti.
 Sono presenti su di essa una serie di pulsanti ed interruttori, un display
 7 segmenti a 4 cifre, una porta VGA, una porta PS/2 e molte altre interfacce
 I/O.
 
\end_layout

\begin_layout Standard
Per realizzare la nostra versione 
\series bold
VHDL 
\series default
del gioco 
\series bold
2048
\series default
,
\series bold
 
\series default
abbiamo deciso di utilizzare i seguenti componenti della scheda fornitaci
 dal professore:
\end_layout

\begin_layout Itemize
l'interfaccia 
\series bold
PS/2
\series default
 tramite tastiera, per dare i comandi di input
\end_layout

\begin_layout Itemize
l'interfaccia 
\series bold
VGA
\series default
 per visualizzare su monitor lo stato della partita
\end_layout

\begin_layout Itemize
il 
\series bold
display da 7 segmenti a 4 cifre
\series default
 per visualizzare il punteggio corrente della partita
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/altera_de1.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Altera Terasic DE1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Quartus II
\end_layout

\begin_layout Standard
Per poter programmare il progetto sulla scheda, è necessario utilizzare
 
\series bold
Quartus II
\series default
, un software di 
\series bold
Altera 
\series default
che, oltre a permettere di interfacciare computer e DE1, è un comodo ambiente
 di sviluppo con cui generare il progetto stesso.
 
\end_layout

\begin_layout Standard
La versione che abbiamo scelto di utilizzare per realizzare questo progetto
 è la 
\series bold
9.1 Web Edition
\series default
, con licenza gratuita.
 Quartus permette sia di comporre una logica unendo porte logiche in uno
 schematico, sia di sintetizzarne di più complesse, tramite descrizione
 
\emph on
Verilog o VHDL
\emph default
, o ad un livello di astrazione più alto, ad esempio con una macchina a
 stati finiti.
\end_layout

\begin_layout Chapter
Implementazione
\end_layout

\begin_layout Section
Modelli di Realizzazione
\end_layout

\begin_layout Subsection
Datapath - Control Unit
\end_layout

\begin_layout Standard
La realizzazione del progetto è stata suddivisa in diversi moduli VHDL in
 accordo col 
\series bold
modello Datapath - Control Unit
\series default
, racchiudendo nel 
\series bold
\emph on
Datapath
\series default
\emph default
 la 
\series bold
\emph on
logica di gioco
\series default
\emph default
 (meccanismo dei movimenti in seguito alle mosse, stato attuale della griglia
 di gioco, punteggio, ...) e nella 
\series bold
\emph on
Control Unit
\series default
\emph default
 la gestione degli input del gioco, ovvero i comandi relativi alle 4 mosse
 effettuabili dal giocatore (
\noun on
SU, GIU, DESTRA, SINISTRA
\noun default
) o il riavvio della partita, ma anche la notifica dello stato della partita
 (
\noun on
GameOver, Vittoria
\noun default
) al giocatore.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/Datapath-ControlUnit.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
DataPath & Control-Unit
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Model - View - Controller
\end_layout

\begin_layout Standard
Nonostante all'interno del 
\series bold
Datapath
\series default
 si abbiano tutte le informazioni necessarie alla visualizzazione del gioco
 mediante la porta VGA, abbiamo scelto di realizzare un componente separato
 che si occupi solamente di tale scopo: la 
\series bold
View
\series default
.
 
\end_layout

\begin_layout Standard
In questo modo si sfrutta il 
\emph on
design pattern
\emph default
 
\series bold
MVC (Model View Controller)
\series default
, nel quale i tre componenti hanno responsabilità separate, favorendo la
 modularità del progetto globale e rendendolo più facilmente estendibile
 e manutenibile.
 
\end_layout

\begin_layout Standard
Di conseguenza avremo 3 macrocomponenti:
\end_layout

\begin_layout Itemize

\series bold
Datapath (detto anche Model)
\series default
: conterrà la cosiddetta 
\begin_inset Quotes fld
\end_inset


\emph on
logica applicativa
\emph default

\begin_inset Quotes frd
\end_inset

, ovvero le operazioni che realizzeranno le funzionalità operative dell'applicaz
ione
\end_layout

\begin_layout Itemize

\series bold
View: 
\series default
sarà utilizzata per mostrare a video i contenuti del modello; dovrà quindi
 implementare i meccanismi per disegnare 
\begin_inset Quotes fld
\end_inset

pixel per pixel
\begin_inset Quotes frd
\end_inset

 l'intera griglia di gioco e per la gestione del 
\emph on
protocollo di comunicazione 
\series bold
\emph default
VGA
\series default
.
 È un osservatore passivo e non influenza il 
\emph on
modello
\emph default
 in alcun modo
\end_layout

\begin_layout Itemize

\series bold
Control Unit (detta anche Controller)
\series default
: riceverà tutti gli input dell'utente e dovrà gestire i relativi eventi,
 decidendo cosa debba fare il 
\emph on
modello
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/MVC.png
	scale 65

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Pattern Model View Controller
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Gestione dell'I/O
\end_layout

\begin_layout Standard
Come si può vedere in 
\noun on
Figura 3.2
\noun default
, oltre ai tre sopracitati componenti che descrivono 
\emph on
Model, View e Controller
\emph default
, il nostro progetto dovrà comprendere inoltre anche i due moduli per la
 gestione dell'
\emph on
Input
\emph default
 da 
\series bold
tastiera
\series default
 e dell'
\emph on
Output
\emph default
 su 
\series bold
monitor
\series default
 e sui quattro 
\series bold
display 7 segmenti
\series default
.
\end_layout

\begin_layout Subsection
Interfaccia PS/2 (INPUT)
\end_layout

\begin_layout Standard
In questa sezione ci occuperemo di descrivere nel dettaglio come abbiamo
 realizzato il componente ausiliario interfacciato direttamente con la porta
 
\series bold
PS/2
\series default
, per la gestione dell'input da tastiera.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/ps2_interface.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Interfaccia PS/2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Protocollo
\end_layout

\begin_layout Standard
Il 
\series bold
PS/2
\series default
 è un protocollo 
\emph on
seriale, sincrono e bidirezionale
\emph default
 sviluppato dall’IBM e ampiamente usato al giorno d’oggi per far comunicare
 PC con tastiere e mouse.
\end_layout

\begin_layout Standard
La scheda 
\series bold
DE1
\series default
 ha in dotazione una porta PS/2 a 6-pin 
\noun on
Mini-DIN
\noun default
; per le porte PS/2 esiste anche un altro connettore, il 5-pin 
\noun on
Mini-DIN
\noun default
 (
\emph on
AT/XT
\emph default
): i due connettori sono (dal punto di vista elettrico) perfettamente compatibil
i (il protocollo è sempre il PS/2, l’unica differenza sta nella disposizione
 dei pin), per cui nel caso si possedesse una tastiera con connettore a
 5-pin è sufficiente l’uso di un adattatore.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/ATXT-PS2.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Differenze AT/XT - PS/2
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Come si può capire dalle figure precedenti, tutta la comunicazione si basa
 su un 
\emph on
bus formato da 
\series bold
due
\series default
 linee bidirezionali
\emph default
: la linea di 
\series bold
clock
\series default
 e la linea 
\series bold
dati
\series default
.
 
\end_layout

\begin_layout Standard
Il bus è in uno stato di attesa quando le due linee di clock e di dati sono
 in uno stato logico alto: questo è l’unico stato nel quale è permesso alla
 tastiera trasmettere dati.
 L’host (che nel nostro caso è appunto la board) ha sempre il controllo
 finale sul bus e può in ogni momento inibire la comunicazione mettendo
 a massa la linea di clock; alla tastiera invece (
\emph on
e solo a lei
\emph default
) spetta il compito di 
\series bold
generare il clock
\series default
.
\end_layout

\begin_layout Subsubsection
La Tastiera
\end_layout

\begin_layout Standard
La tastiera consiste in una 
\emph on
matrice di tasti
\emph default
 ciascuno dei quali viene monitorato da un processore interno alla tastiera.
 
\end_layout

\begin_layout Standard
Ogni tastiera possiede un processore specifico (diverso dagli altri in base
 alle caratteristiche della tastiera), ma tutti quanti i processori fanno
 sostanzialmente lo stesso lavoro: controllano quale tasto viene premuto/rilasci
ato e spediscono all’host il dato appropriato; all’occorrenza si occupano
 di bufferizzare i dati se la linea di comunicazione risulta occupata.
\end_layout

\begin_layout Standard
Il 
\emph on

\begin_inset Quotes fld
\end_inset

pacchetto di informazioni
\emph default

\begin_inset Quotes frd
\end_inset

 trasmesso dalla tastiera all'host viene chiamato 
\series bold
Scan Code
\series default
.
 
\end_layout

\begin_layout Subsubsection
Scan code
\end_layout

\begin_layout Standard
Esistono due tipi di 
\emph on
scan codes
\emph default
: 
\end_layout

\begin_layout Itemize

\series bold
Make codes
\series default
: vengono spediti quando un tasto è premuto o viene tenuto premuto
\end_layout

\begin_layout Itemize

\series bold
Break codes
\series default
: utilizzati quando un tasto è rilasciato, nel nostro caso è sempre 
\begin_inset Quotes fld
\end_inset


\series bold
F0
\series default

\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard

\series bold
Ogni tasto è associato ad un unica coppia 
\begin_inset Quotes fld
\end_inset

make code / break code
\series default

\begin_inset Quotes frd
\end_inset

, in tal modo l’host può determinare esattamente cos'è successo e a che
 tasto semplicemente guardando il singolo scan code.
 Il set di 
\emph on
make e break code
\emph default
 per ogni tasto forma quello che viene chiamato 
\series bold
scan code set
\series default
.
 
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align left
\begin_inset Graphics
	filename img/keyboard.png
	scale 75

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Scan code set
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Comunicazione
\end_layout

\begin_layout Standard
Come visto precedentemente, i due pins della scheda per la comunicazione
 sono 
\series bold
PS2_CLK
\series default
 (il clock della periferica collegata) e 
\series bold
PS2_DAT
\series default
 (attraverso il quale arrivano le informazioni).
 
\end_layout

\begin_layout Standard
La comunicazione avviene in modo 
\emph on
seriale
\emph default
, infatti PS2_DAT permette la trasmissione di un singolo bit alla volta,
 per questo motivo occorre predisporre un apposito modulo che gestisca il
 flusso di bit in ingresso, dando in uscita pacchetti contenenti le informazioni
 in modo ordinato.
\end_layout

\begin_layout Standard
Il componente da noi creato, che si occupa di ricostruire lo 
\series bold
Scan Code
\series default
 contiene un 
\bar under
contatore da 0 a 10
\bar default
: ogni singolo messaggio inviato dalla tastiera conterrà:
\end_layout

\begin_layout Itemize
un 
\emph on
bit di start
\emph default
, posto sempre a 0
\end_layout

\begin_layout Itemize
la 
\emph on
codifica del dato
\emph default
, ordinati dal meno significativo
\end_layout

\begin_layout Itemize
un
\emph on
 bit di parità
\end_layout

\begin_layout Itemize
un 
\emph on
bit di fine messaggio
\emph default
, posto sempre a 1
\end_layout

\begin_layout Standard
La nostra interfaccia dovrà quindi leggere gli 
\emph on
11 bit e costruire il dato a 8 bit desiderato
\emph default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/keyboard_timings.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Comunicazione Tastiera -> Board 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Il Componente 
\begin_inset Quotes fld
\end_inset

Tastiera
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Standard
Nel nostro progetto abbiamo deciso di realizzare un singolo componente che
 comunichi direttamente con la 
\emph on
porta PS/2
\emph default
, lasciando alla 
\series bold
Control Unit 
\series default
solo il compito di riconoscere gli 
\series bold
scan codes 
\series default
ed agire di conseguenza.
 In particolare, il modulo emette la codifica ricevuta serialmente dalla
 tastiera fino alla ricezione del 
\series bold
break code
\series default
, continuando ad emettere quindi 
\begin_inset Quotes fld
\end_inset


\series bold
F0
\series default

\begin_inset Quotes frd
\end_inset

 fino alla ricezione di un nuovo codice.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Subsection
Interfaccia VGA (OUTPUT)
\end_layout

\begin_layout Standard
In questa sezione ci occuperemo di descrivere nel dettaglio come abbiamo
 realizzato il componente ausiliario interfacciato direttamente con la porta
 
\series bold
VGA
\series default
, per la gestione dell'output a video.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_interface.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Interfaccia VGA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Protocollo
\end_layout

\begin_layout Standard
Il 
\series bold
VGA
\series default
 (
\emph on
Video Graphics Array
\emph default
) è uno standard analogico introdotto da IBM alla fine degli anni '80, comunemen
te impiegato nella visualizzazione di immagini a display da parte di computers.
 
\end_layout

\begin_layout Standard
Concepito inizialmente come singolo chip allo scopo di sostituire altri
 standard e hardware preesistenti sul mercato, con il passare del tempo
 si è imposto come standard universalmente riconosciuto per il pilotaggio
 di display, tanto da essere impiegato anche attualmente: le schede grafiche
 presenti sul mercato devono essere almeno in grado di gestire lo schermo
 con lo 
\emph on
standard VGA
\emph default
, prima che venga effettuato il boot del sistema operativo e quindi caricato
 il driver specifico di ogni scheda.
\end_layout

\begin_layout Standard
La connessione VGA standard termina con uno spinotto maschio a 15-pin, il
 cui pinout è mostrato in 
\noun on
Figura 3.8
\noun default
.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename img/vga_pinout.jpg

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Pinout VGA
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Come si evince dalla figura precedente, lo standard video VGA prevede 
\series bold
5 segnali attivi
\series default
: 
\end_layout

\begin_layout Itemize

\series bold
\color red
Rosso (
\emph on
Red
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore rosso sullo schermo (
\emph on
pin 1
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color green
Verde (
\emph on
Green
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore verde sullo schermo (
\emph on
pin 2
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color blue
Blu (
\emph on
Blue
\emph default
)
\series default
\color inherit
: dedicato alla generazione del colore blu sullo schermo (
\emph on
pin 3
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color magenta
Sincronismo orizzontale (
\emph on
H Sync
\emph default
)
\series default
\color inherit
: usato per la sincronizzazione del video (
\emph on
pin 13
\emph default
)
\end_layout

\begin_layout Itemize

\series bold
\color magenta
Sincronismo verticale (
\emph on
V Sync
\emph default
)
\series default
\color inherit
: usato per la sincronizzazione del video (
\emph on
pin 14
\emph default
)
\end_layout

\begin_layout Standard
Lo schermo viene diviso in pixel ed il colore di ciascuno di essi è determinato
 dal valore di tensione del segnale 
\series bold
RGB
\series default
.
 Se un certo 
\emph on

\begin_inset Quotes fld
\end_inset

canale colore
\emph default

\begin_inset Quotes frd
\end_inset

 viene pilotato a valore minimo di tensione, si ha che tale colore non viene
 visualizzato a schermo in corrispondenza di quel particolare pixel (
\emph on
colore spento
\emph default
), mentre se lo stesso 
\begin_inset Quotes fld
\end_inset


\emph on
canale colore
\emph default

\begin_inset Quotes frd
\end_inset

 viene pilotato a 
\bar under
tensione massima
\bar default
, si ha la 
\bar under
massima brillantezza possibile
\bar default
 di quel determinato colore per quel particolare pixel.
 
\end_layout

\begin_layout Standard
Solitamente viene assegnato a ciascuno dei segnali colore (
\series bold
RGB
\series default
) un certo numero di bit, il cui valore, attraverso un semplice 
\emph on
convertitore digitale analogico resistivo
\emph default
 (
\noun on
Figura 3.7
\noun default
), ne determina il livello di tensione che andrà poi a colorare i pixel
 a schermo.
 Nel nostro caso si utilizzano 
\bar under
4 bit per colore
\bar default
, per un totale di 
\bar under
12 bit di codifica
\bar default
 per un singolo 
\emph on
colore RGB
\emph default
: questo rende possibili 
\series bold
4096
\series default
 
\bar under
tonalità di colori
\end_layout

\begin_layout Standard
I segnali di 
\series bold
sincronismo orizzontale e verticale
\series default
 sono segnali interamente digitali, compatibili con i livelli della 
\emph on
logica TTL
\emph default
.
\end_layout

\begin_layout Subsubsection
VGA Mode
\end_layout

\begin_layout Section
Implementazione del modello
\end_layout

\begin_layout Standard
Come già detto precedentemente la realizzazione del componente Model del
 design pattern MVC sarà un punto critico per la realizzazione di questo
 progetto.
 Per questo motivo abbiamo deciso di affrontare questo argomento prima della
 realizzazione delle altre parti.
\end_layout

\begin_layout Subsection
Struttura del modello
\end_layout

\begin_layout Standard
Analizzando il gioco abbiamo notato che per ogni singolo instante della
 partita avremo la necessità di rappresentare lo stato delle 16 caselle
 (4x4) che compongono la 
\begin_inset Quotes fld
\end_inset

scacchiera
\begin_inset Quotes frd
\end_inset

.
 Ogni singola cella è rappresentata quindi da un valore numerico compreso
 tra 0 e 2048.
 Quindi si è realizzato che per poter mantenere lo stato attuale del gioco
 sarebbe necessario utilizzare una matrice 4x4 di interi, ognuno rappresentante,
 appunto, il valore attuale della propria cella.
 Quindi ripensando un attimo al gioco viene in mente subito che all'istante
 iniziale il gioco avrà uno stato composto da 16 celle con valore 0, quest
 ultimo non verrà mostrato a livello di interfaccia grafica perchè rappresenterà
 semplicemente la cella vuota.
 Inoltre, l'altro stato notevole sarà quello dove almeno una delle n celle
 avrà assunto il valore di 2048, questo rappresentarà lo stato di terminazione
 corrispondente alla vittoria dell'utente.
\end_layout

\begin_layout Standard
Ulteriormente allo stato corrente sarà necessario mantenere informazioni
 riguardo il punteggio attuale, rappresentabile con un intero.
 Quindi riassumendo serviranno due informazioni per ogni istante di gioco:
 
\end_layout

\begin_layout Itemize
matrice 4x4 con i valori delle celle;
\end_layout

\begin_layout Itemize
punteggio attuale conseguito dall'utente;
\end_layout

\begin_layout Subsection
Azioni sul modello
\end_layout

\begin_layout Standard
Avendo stabilito quale sia la rappresentazione dello stato, ora, serve comprende
re quali sono le azioni che il nostro modello deve poter compiere per poter
 modificare lo stato in risposta all'input inviato dall'utente.
 Naturalmente il gioco prevede i movimenti nelle 4 direzioni, nella struttura
 del gioco originali questi movimenti comportano principalmente due conseguenze:
\end_layout

\begin_layout Enumerate
Le celle vengono traslate dalla propria posizione iniziale verso la cella
 massima libera raggiungibile nella direzione d'ingresso.
 In altre parole, supponiamo che l'utente abbia selezionato la direzione
 destra: il gioco deve controllare per ogni n-esima cella se la propria
 cella adiacente (verso destra) sia libera, in caso positivo essa dovrà
 
\begin_inset Quotes fld
\end_inset

spostarsi
\begin_inset Quotes frd
\end_inset

 nella direzione specificata.
 
\end_layout

\begin_layout Enumerate
L'operazione di movimento è quindi necessaria, ma non sufficiente per comprender
e il funzionamento di 2048.
 L'altra azione quindi è il 
\series bold
merge
\series default
, ovvero 
\begin_inset Quotes fld
\end_inset

l'unione
\begin_inset Quotes frd
\end_inset

 di due caselle.
 Anche il merge avviene in base alla direzione specificata dall'utente,
 in questo caso però se la cella nella direzione prescritta ha lo stesso
 valore della cella in analisi, allora il valore della cella verso la quale
 si fa il merge assumerà come nuovo valore la somma dei due valori.
\end_layout

\begin_layout Standard
Infine la meccanica di gioco prevede che conseguentemente ad ogni spostamento
 o merge venga, se libera almeno una casella, inserito un valore 
\series bold
2 
\series default
in posizione casuale.
 
\end_layout

\begin_layout Standard
Quindi supponendo si dovranno modificare i valori degli interi della matrice
 4x4 in base alle azioni intraprese dall'utente, questo farà sì che l'evoluzione
 del gioco sia costantemente mantenuta.
 
\end_layout

\end_body
\end_document
